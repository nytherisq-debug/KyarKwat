<!DOCTYPE html>
<html lang="my">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no">
<title>á€€á€»á€¬á€¸á€€á€½á€€á€º Â· Myanmar Traditional Checkers</title>
<link href="https://fonts.googleapis.com/css2?family=Noto+Sans+Myanmar:wght@400;700;900&family=Cinzel+Decorative:wght@700&display=swap" rel="stylesheet">
<style>
/* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
   VARIABLES
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
:root {
  --gold:      #FFD700;
  --gold-dk:   #B8860B;
  --gold-lt:   #FFF5C0;
  --red:       #CC2200;
  --red-dk:    #8B0000;
  --bg:        #130800;
  --panel:     #1e0d04;
  --panel2:    #2a1208;
  --border:    #5a3010;
  --txt:       #FFE4A0;
  --txt-dim:   #a07040;
  --cell-lt:   #C8A96A;
  --cell-dk:   #6B4400;
  --cell-sel:  #A06000;
  --cell-vm:   #1a6a28;
  --grn:       #22dd44;
}
* { margin:0; padding:0; box-sizing:border-box; -webkit-tap-highlight-color:transparent; }
html,body { height:100%; overflow:hidden; }
body {
  background: var(--bg);
  font-family: 'Noto Sans Myanmar', sans-serif;
  color: var(--txt);
  display: flex;
  flex-direction: column;
  height: 100vh;
}

/* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
   SCREENS
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
.screen { display:none; flex-direction:column; height:100%; overflow:hidden; }
.screen.active { display:flex; }

/* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
   HEADER
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
.app-header {
  text-align: center;
  padding: 12px 10px 8px;
  background: linear-gradient(180deg, #1e0800, transparent);
  flex-shrink: 0;
}
.app-header .my-title {
  font-size: clamp(22px, 6vw, 36px);
  font-weight: 900;
  color: var(--gold-lt);
  text-shadow: 0 0 20px #FFD70099;
  line-height: 1;
}
.app-header .en-title {
  font-family: 'Cinzel Decorative', serif;
  font-size: clamp(10px, 2.5vw, 16px);
  color: var(--gold-dk);
  letter-spacing: 2px;
  margin-top: 2px;
}
.app-header::after {
  content: '';
  display: block;
  height: 1px;
  background: linear-gradient(90deg, transparent, var(--gold-dk), transparent);
  margin-top: 8px;
}

/* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
   LOBBY
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
#lobby {
  overflow-y: auto;
  padding: 14px 12px 20px;
  gap: 12px;
}
.card {
  background: var(--panel2);
  border: 1px solid var(--border);
  border-radius: 12px;
  padding: 18px 16px;
  width: 100%;
  max-width: 420px;
  margin: 0 auto;
}
.card-title {
  font-size: 14px;
  font-weight: 700;
  color: var(--gold);
  text-align: center;
  margin-bottom: 14px;
  padding-bottom: 10px;
  border-bottom: 1px solid var(--border);
}
.field-lbl { font-size: 11px; color: var(--txt-dim); margin-bottom: 4px; letter-spacing: 1px; }
.field-inp {
  width: 100%; padding: 10px 13px;
  background: #0d0500; border: 1px solid var(--border); border-radius: 7px;
  color: var(--txt); font-family: inherit; font-size: 14px;
  outline: none; margin-bottom: 10px; transition: border-color .2s;
}
.field-inp:focus { border-color: var(--gold); }
.field-inp.code-inp {
  text-transform: uppercase; letter-spacing: 6px;
  text-align: center; font-size: 18px; font-weight: 900;
}
.btn {
  width: 100%; padding: 12px; border: none; border-radius: 8px;
  font-family: inherit; font-size: 14px; font-weight: 700;
  cursor: pointer; transition: all .2s; margin-bottom: 7px;
  letter-spacing: .5px;
}
.btn:last-child { margin-bottom: 0; }
.btn-gold {
  background: linear-gradient(135deg, var(--gold-dk), var(--gold), var(--gold-dk));
  color: #1a0800;
  box-shadow: 0 3px 14px #FFD70030;
}
.btn-gold:hover { transform: translateY(-1px); box-shadow: 0 5px 20px #FFD70050; }
.btn-ghost {
  background: transparent;
  border: 1.5px solid var(--border);
  color: var(--gold);
}
.btn-ghost:hover { background: #FFD70010; border-color: var(--gold-dk); }
.btn-danger {
  background: linear-gradient(135deg, var(--red-dk), var(--red));
  color: #fff; font-size: 13px; padding: 10px;
}
.sep {
  text-align: center; font-size: 11px; color: var(--txt-dim);
  margin: 8px 0; position: relative;
}
.sep::before,.sep::after {
  content:''; position:absolute; top:50%; width:40%; height:1px; background:var(--border);
}
.sep::before{left:0} .sep::after{right:0}

/* waiting */
.code-display {
  background: #080300; border: 2px dashed var(--gold);
  border-radius: 9px; padding: 13px; text-align: center; margin: 10px 0;
}
.code-big { font-size: 28px; font-weight: 900; color: var(--gold); letter-spacing: 8px; text-shadow: 0 0 16px #FFD70088; }
.code-hint { font-size: 11px; color: var(--txt-dim); margin-top: 3px; }
.wait-row { display:flex; align-items:center; justify-content:center; gap:8px; color:var(--txt-dim); font-size:13px; margin-top:10px; }
.spinner { width:16px;height:16px; border:2px solid var(--border); border-top-color:var(--gold); border-radius:50%; animation:spin .9s linear infinite; }
@keyframes spin{to{transform:rotate(360deg)}}

/* rules accordion */
.rules-toggle {
  background: none; border: none; color: var(--txt-dim); font-family: inherit;
  font-size: 12px; cursor: pointer; text-decoration: underline;
  display: block; margin: 4px auto 0; text-align: center;
}
.rules-body {
  display: none; margin-top: 10px; font-size: 11.5px;
  line-height: 1.9; color: var(--txt-dim);
  background: #0a0400; border-radius: 7px; padding: 11px 13px;
}
.rules-body.open { display:block; }
.rules-body b { color: var(--gold); }

/* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
   GAME SCREEN LAYOUT
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
#game {
  flex-direction: row;  /* side-by-side on wide, stacked on narrow */
}

/* Main play area */
.play-area {
  flex: 1;
  display: flex;
  flex-direction: column;
  align-items: center;
  overflow: hidden;
  padding: 6px 8px;
  gap: 6px;
  min-width: 0;
}

/* Chat panel */
.chat-panel {
  width: 240px;
  flex-shrink: 0;
  display: flex;
  flex-direction: column;
  background: var(--panel2);
  border-left: 1px solid var(--border);
  overflow: hidden;
}

@media (max-width: 640px) {
  #game { flex-direction: column; }
  .chat-panel {
    width: 100%;
    height: 160px;
    border-left: none;
    border-top: 1px solid var(--border);
    flex-shrink: 0;
  }
}

/* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
   PLAYER / SCORE BAR
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
.score-strip {
  display: flex; align-items: center; justify-content: center;
  gap: 12px; font-size: 12px; color: var(--txt-dim); flex-shrink: 0;
}
.score-n { font-size: 18px; font-weight: 900; color: var(--gold); }

.players-bar {
  display: flex; align-items: center; justify-content: space-between;
  width: 100%; max-width: 500px; gap: 8px; flex-shrink: 0;
}
.player-card {
  flex: 1; background: var(--panel);
  border: 2px solid transparent; border-radius: 9px;
  padding: 8px 10px; transition: all .3s; position: relative; overflow: hidden;
}
.player-card.active { border-color: var(--gold); box-shadow: 0 0 14px #FFD70055; }
.player-card.active::after {
  content:'â–¶'; position:absolute; right:7px; top:50%;
  transform:translateY(-50%); color:var(--gold); font-size:9px;
  animation: blink 1s infinite;
}
@keyframes blink{0%,100%{opacity:1}50%{opacity:.1}}
.pc-row { display:flex; align-items:center; gap:5px; }
.dot { width:12px;height:12px;border-radius:50%;flex-shrink:0; }
.dot-y { background:radial-gradient(circle at 35% 35%,#ffe040,#8B6914); border:1.5px solid #FFD700; }
.dot-b { background:radial-gradient(circle at 35% 35%,#5577dd,#0a1a5c); border:1.5px solid #7799ff; }
.pc-name { font-size:11px; font-weight:700; overflow:hidden; text-overflow:ellipsis; white-space:nowrap; }
.pc-count { font-size:10px; color:var(--txt-dim); margin-top:2px; }

.mid-col { text-align:center; flex-shrink:0; }
.vs-lbl { font-family:'Cinzel Decorative',serif; font-size:11px; color:var(--gold-dk); }
.timer { font-size:20px; font-weight:900; color:var(--gold); min-width:36px; font-variant-numeric:tabular-nums; }
.timer.urgent { color:var(--red); animation:blink .5s infinite; }

/* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
   STATUS BAR
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
.status-bar {
  background: var(--panel); border:1px solid var(--border); border-radius:8px;
  padding:8px 16px; text-align:center; width:100%; max-width:500px;
  font-size:13px; font-weight:700; color:var(--gold);
  min-height:38px; display:flex; align-items:center; justify-content:center;
  flex-shrink:0;
}

/* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
   BOARD
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
.board-wrap {
  position: relative;
  flex-shrink: 0;
}
.board-frame {
  background: linear-gradient(135deg, #5a2e10, #2a1008, #5a2e10);
  padding: 8px; border-radius: 10px;
  box-shadow: 0 0 0 1px var(--border), 0 8px 32px #00000099;
  position: relative;
}
.board-frame::before {
  content:''; position:absolute; inset:2px;
  border:1px solid var(--gold-dk); border-radius:8px;
  pointer-events:none; z-index:20;
}
.board-inner { position:relative; }

#board {
  display: grid;
  grid-template-columns: repeat(8, 1fr);
  grid-template-rows: repeat(8, 1fr);
  /* Dynamically sized via JS */
  width: var(--board-size, min(80vw, 380px));
  height: var(--board-size, min(80vw, 380px));
  border-radius: 2px;
  overflow: hidden;
}

/* SVG overlay for move arrows */
#arrow-svg {
  position: absolute; top:0; left:0; width:100%; height:100%;
  pointer-events: none; z-index:15; overflow:visible;
}

/* Cells */
.cell { position:relative; cursor:default; overflow:hidden; }
.cell.lt { background: var(--cell-lt); }
.cell.dk { background: var(--cell-dk); }
.cell.dk.sel { background: var(--cell-sel) !important; }
.cell.dk.vm { background: var(--cell-vm); cursor:pointer; }

/* pulse dot on valid move */
.cell.dk.vm::after {
  content:''; position:absolute; inset:32%;
  border-radius:50%; background:#ffffff25;
  animation:vmpulse 1.1s ease-in-out infinite;
}
@keyframes vmpulse { 0%,100%{transform:scale(1);opacity:.6} 50%{transform:scale(1.15);opacity:1} }

/* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
   PIECES
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
.piece {
  position:absolute; inset:7%;
  border-radius:50%;
  cursor:pointer;
  transition: transform .14s, box-shadow .14s;
  display:flex; align-items:center; justify-content:center;
  user-select:none; z-index:5;
}
.piece:hover { transform:scale(1.06); }
.piece.py {
  background: radial-gradient(circle at 35% 30%, #fff176, #b8860b);
  border: 3px solid #FFD700;
  box-shadow: 0 3px 8px #00000088, 0 0 0 1px #7a5800, inset 0 -2px 5px #00000044;
}
.piece.pb {
  background: radial-gradient(circle at 35% 30%, #6688ee, #0d1d6e);
  border: 3px solid #99aaff;
  box-shadow: 0 3px 8px #00000088, 0 0 0 1px #0a1060, inset 0 -2px 5px #00000044;
}
.piece.king::after {
  content:'â™›';
  font-size: clamp(9px, 2.2vw, 15px);
  text-shadow: 0 0 5px #000;
}
.piece.py.king::after { color: var(--gold-dk); }
.piece.pb.king::after { color: #ffffff; }
.piece.lifted {
  transform: scale(1.14) translateY(-4px) !important;
  box-shadow: 0 8px 20px #00000099, 0 0 16px #FFD70066 !important;
  z-index: 10 !important;
}

/* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
   MOVE LOG
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
.move-log {
  width:100%; max-width:500px;
  background:var(--panel); border:1px solid var(--border); border-radius:7px;
  padding:6px 10px; height:44px; overflow-y:auto;
  display:flex; flex-wrap:wrap; gap:3px; align-content:flex-start;
  flex-shrink:0;
}
.move-log span { font-size:10px; background:#0a0400; border-radius:3px; padding:2px 5px; }
.move-log .y-mv { border-left:2px solid #FFD700; color:var(--gold-dk); }
.move-log .b-mv { border-left:2px solid #4466cc; color:#6688cc; }

/* game buttons */
.game-btns { display:flex; gap:8px; width:100%; max-width:500px; flex-shrink:0; }
.game-btns .btn { font-size:12px; padding:10px; margin:0; }

/* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
   CHAT PANEL
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
.chat-header {
  padding:10px 12px 8px;
  border-bottom:1px solid var(--border);
  font-size:12px; font-weight:700; color:var(--gold);
  flex-shrink:0;
}
.chat-messages {
  flex:1; overflow-y:auto;
  padding:8px 10px;
  display:flex; flex-direction:column; gap:6px;
}
.chat-msg { display:flex; flex-direction:column; max-width:90%; }
.chat-msg.mine { align-self:flex-end; align-items:flex-end; }
.chat-msg.theirs { align-self:flex-start; align-items:flex-start; }
.chat-bubble {
  padding:6px 9px; border-radius:10px;
  font-size:12px; line-height:1.4; word-break:break-word;
}
.chat-msg.mine .chat-bubble { background:#5a3010; color:var(--gold-lt); border-radius:10px 10px 2px 10px; }
.chat-msg.theirs .chat-bubble { background:#1a0d04; color:var(--txt); border:1px solid var(--border); border-radius:10px 10px 10px 2px; }
.chat-sender { font-size:10px; color:var(--txt-dim); margin-bottom:2px; }
.chat-system { text-align:center; font-size:10px; color:var(--txt-dim); font-style:italic; }

.chat-input-row {
  display:flex; gap:6px; padding:8px 10px;
  border-top:1px solid var(--border); flex-shrink:0;
}
.chat-inp {
  flex:1; padding:7px 9px;
  background:#0a0400; border:1px solid var(--border); border-radius:6px;
  color:var(--txt); font-family:inherit; font-size:12px; outline:none;
}
.chat-inp:focus { border-color:var(--gold-dk); }
.chat-send {
  padding:7px 11px;
  background:var(--gold-dk); color:#1a0800;
  border:none; border-radius:6px; font-size:13px;
  cursor:pointer; flex-shrink:0;
}

/* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
   WIN MODAL
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
.overlay {
  display:none; position:fixed; inset:0;
  background:#00000099; backdrop-filter:blur(4px);
  z-index:100; align-items:center; justify-content:center;
}
.overlay.show { display:flex; }
.modal {
  background: linear-gradient(135deg, var(--panel2), #3d1e08);
  border:2px solid var(--gold); border-radius:16px;
  padding:32px 26px; text-align:center;
  max-width:320px; width:90%;
  box-shadow:0 20px 60px #000c, 0 0 30px #FFD70033;
  animation: popIn .4s cubic-bezier(.175,.885,.32,1.275);
}
@keyframes popIn{from{transform:scale(.5);opacity:0}to{transform:scale(1);opacity:1}}
.modal-icon { font-size:50px; margin-bottom:10px; }
.modal h2 { font-size:20px; color:var(--gold); margin-bottom:6px; }
.modal p  { font-size:13px; color:var(--txt-dim); margin-bottom:20px; }

/* TOAST */
.toast {
  position:fixed; bottom:20px; left:50%; transform:translateX(-50%) translateY(80px);
  background:var(--panel2); border:1px solid var(--border);
  border-radius:20px; padding:9px 18px; font-size:13px;
  z-index:200; transition:transform .3s; white-space:nowrap;
  max-width:90vw; overflow:hidden; text-overflow:ellipsis;
}
.toast.show { transform:translateX(-50%) translateY(0); }
</style>
</head>
<body>

<!-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
     LOBBY SCREEN
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• -->
<div id="lobby" class="screen active">
  <div class="app-header">
    <div class="my-title">á€€á€»á€¬á€¸á€€á€½á€€á€º</div>
    <div class="en-title">KYAR KWAT Â· Myanmar Traditional Checkers</div>
  </div>

  <!-- Main card -->
  <div class="card" style="margin-top:8px">
    <div class="card-title">ğŸ® á€€á€…á€¬á€¸á€”á€Šá€ºá€¸á€›á€½á€±á€¸á€á€»á€šá€ºá€•á€«</div>

    <div class="field-lbl">á€á€„á€ºáá€”á€¬á€™á€Šá€º</div>
    <input class="field-inp" id="inp-name" type="text" placeholder="á€”á€¬á€™á€Šá€ºá€‘á€Šá€·á€ºá€•á€«..." maxlength="20">

    <button class="btn btn-gold" onclick="ui.createRoom()">ğŸ  Online Room á€–á€”á€ºá€á€®á€¸á€•á€«</button>
    <div class="sep">á€á€­á€¯á€·á€™á€Ÿá€¯á€á€º</div>

    <div class="field-lbl">Room Code á€–á€¼á€„á€·á€ºá€á€„á€ºá€•á€«</div>
    <input class="field-inp code-inp" id="inp-code" type="text" placeholder="CODE" maxlength="6">
    <button class="btn btn-ghost" onclick="ui.joinRoom()">ğŸšª Room á€á€„á€ºá€•á€«</button>
    <div class="sep">á€á€­á€¯á€·á€™á€Ÿá€¯á€á€º</div>

    <button class="btn btn-ghost" onclick="ui.startAI()">ğŸ¤– AI á€”á€¾á€„á€·á€ºá€€á€…á€¬á€¸á€•á€«</button>
    <button class="btn btn-ghost" onclick="ui.startLocal()">ğŸ‘¥ á‚ á€šá€±á€¬á€€á€º Local á€€á€…á€¬á€¸á€•á€«</button>

    <button class="rules-toggle" onclick="document.getElementById('rules').classList.toggle('open')">
      ğŸ“– á€€á€»á€¬á€¸á€€á€…á€¬á€¸á€”á€Šá€ºá€¸á€™á€»á€¬á€¸ á€–á€á€ºá€›á€”á€ºá€”á€¾á€­á€•á€ºá€•á€«
    </button>
    <div class="rules-body" id="rules">
      <b>ğŸ Board Setup</b><br>
      â€¢ 8Ã—8 (á†á„ á€€á€½á€€á€º) Â· á€á€…á€ºá€˜á€€á€º áá‚ á€€á€»á€¬á€¸<br>
      â€¢ á€¡á€”á€€á€ºá€€á€½á€€á€ºá€•á€±á€«á€ºá€á€¬ á€á€»á€‘á€¬á€¸ Â· áƒ á€á€”á€ºá€¸á€…á€®<br><br>
      <b>â™Ÿ á€›á€½á€±á€·á€œá€»á€¬á€¸á€”á€Šá€ºá€¸</b><br>
      â€¢ á€á€¬á€™á€”á€ºá€€á€»á€¬á€¸ â€” á€›á€¾á€±á€· diagonal á€á€…á€ºá€€á€½á€€á€º<br>
      â€¢ á€€á€»á€¬á€¸á€˜á€¯á€›á€„á€º (â™›) â€” á„ á€–á€€á€ºá€œá€¯á€¶á€¸ diagonal á€™á€Šá€ºá€™á€»á€¾á€™á€†á€­á€¯<br><br>
      <b>âš ï¸ á€–á€™á€ºá€¸á€…á€¬á€¸á€”á€Šá€ºá€¸</b><br>
      â€¢ á€–á€™á€ºá€¸á€…á€›á€¬á€›á€¾á€­á€œá€»á€¾á€„á€º <u>á€™á€–á€¼á€…á€ºá€™á€”á€± á€–á€™á€ºá€¸á€›á€™á€Šá€º</u><br>
      â€¢ á€†á€€á€ºá€á€­á€¯á€€á€ºá€–á€™á€ºá€¸á€”á€­á€¯á€„á€ºá€œá€»á€¾á€„á€º á€†á€¯á€¶á€¸á€á€Šá€ºá€¡á€‘á€­ á€†á€€á€ºá€–á€™á€ºá€¸á€›á€™á€Šá€º<br>
      â€¢ á€–á€™á€ºá€¸á€”á€­á€¯á€„á€ºá€á€±á€¬ á€œá€™á€ºá€¸á€€á€¼á€±á€¬á€„á€ºá€¸á€”á€¾á€…á€ºá€á€¯á€›á€¾á€­á€•á€«á€€ <u>á€¡á€™á€»á€¬á€¸á€†á€¯á€¶á€¸á€–á€™á€ºá€¸á€”á€­á€¯á€„á€ºá€á€±á€¬á€œá€™á€ºá€¸</u>á€€á€­á€¯á€á€¬ á€›á€½á€±á€¸á€›á€™á€Šá€º<br><br>
      <b>ğŸ† á€”á€­á€¯á€„á€ºá€á€¼á€„á€ºá€¸</b><br>
      â€¢ á€†á€”á€·á€ºá€€á€»á€„á€ºá€˜á€€á€º á€€á€»á€¬á€¸á€™á€»á€¬á€¸ á€¡á€¬á€¸á€œá€¯á€¶á€¸á€€á€¯á€”á€ºá€á€¼á€„á€ºá€¸<br>
      â€¢ á€†á€”á€·á€ºá€€á€»á€„á€ºá€˜á€€á€º á€›á€½á€±á€·á€›á€¬á€™á€›á€¾á€­ á€•á€­á€á€ºá€™á€­á€á€¼á€„á€ºá€¸<br>
      â€¢ á„á€ á€œá€¾á€Šá€·á€ºá€á€½á€„á€º á€–á€™á€ºá€¸á€™á€¾á€¯á€™á€›á€¾á€­á€•á€«á€€ â€” á€á€›á€±
    </div>
  </div>

  <!-- Waiting panel -->
  <div class="card" id="wait-card" style="display:none;margin-top:8px">
    <div class="card-title">â³ á€á€°á€„á€šá€ºá€á€»á€„á€ºá€¸á€€á€­á€¯á€…á€±á€¬á€„á€·á€ºá€”á€±á€á€Šá€º</div>
    <div class="code-display">
      <div class="code-big" id="room-code-disp">------</div>
      <div class="code-hint">á€’á€® Code á€€á€­á€¯ á€á€°á€„á€šá€ºá€á€»á€„á€ºá€¸á€€á€­á€¯á€•á€±á€¸á€•á€«</div>
    </div>
    <div class="wait-row">
      <div class="spinner"></div>
      <span>Player 2 á€á€„á€ºá€›á€±á€¬á€€á€ºá€›á€”á€º á€…á€±á€¬á€„á€·á€ºá€”á€±á€á€Šá€º...</span>
    </div>
    <button class="btn btn-danger" onclick="ui.cancelRoom()" style="margin-top:12px">âŒ á€•á€šá€ºá€–á€»á€€á€ºá€•á€«</button>
  </div>
</div>

<!-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
     GAME SCREEN
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• -->
<div id="game" class="screen">

  <!-- PLAY AREA -->
  <div class="play-area">

    <!-- Score -->
    <div class="score-strip">
      <span id="sname1">P1</span>
      <span class="score-n" id="score1">0</span>
      <span style="color:var(--txt-dim)">â€”</span>
      <span class="score-n" id="score2">0</span>
      <span id="sname2">P2</span>
    </div>

    <!-- Players -->
    <div class="players-bar">
      <div class="player-card" id="pc1">
        <div class="pc-row"><span class="dot dot-y"></span><span class="pc-name" id="pname1">P1</span></div>
        <div class="pc-count" id="pcount1">á€€á€»á€¬á€¸: 12</div>
      </div>
      <div class="mid-col">
        <div class="vs-lbl">VS</div>
        <div class="timer" id="timer">60</div>
      </div>
      <div class="player-card" id="pc2">
        <div class="pc-row"><span class="dot dot-b"></span><span class="pc-name" id="pname2">P2</span></div>
        <div class="pc-count" id="pcount2">á€€á€»á€¬á€¸: 12</div>
      </div>
    </div>

    <!-- Status -->
    <div class="status-bar" id="status">á€€á€…á€¬á€¸á€”á€±á€†á€²...</div>

    <!-- Board -->
    <div class="board-wrap">
      <div class="board-frame">
        <div class="board-inner">
          <div id="board"></div>
          <svg id="arrow-svg" xmlns="http://www.w3.org/2000/svg"></svg>
        </div>
      </div>
    </div>

    <!-- Move log -->
    <div class="move-log" id="move-log"></div>

    <!-- Buttons -->
    <div class="game-btns">
      <button class="btn btn-ghost" onclick="ui.goLobby()">ğŸ  á€‘á€½á€€á€º</button>
      <button class="btn btn-ghost" onclick="ui.offerDraw()">ğŸ¤ á€á€›á€±</button>
      <button class="btn btn-ghost" onclick="ui.resetGame()">ğŸ”„ á€•á€¼á€”á€ºá€…á€•á€«</button>
    </div>

  </div>

  <!-- CHAT PANEL -->
  <div class="chat-panel">
    <div class="chat-header">ğŸ’¬ Chat</div>
    <div class="chat-messages" id="chat-msgs"></div>
    <div class="chat-input-row">
      <input class="chat-inp" id="chat-inp" type="text" placeholder="á€…á€¬á€›á€­á€¯á€€á€ºá€•á€«..." maxlength="120"
             onkeydown="if(event.key==='Enter')ui.sendChat()">
      <button class="chat-send" onclick="ui.sendChat()">â–¶</button>
    </div>
  </div>

</div>

<!-- WIN MODAL -->
<div class="overlay" id="win-overlay">
  <div class="modal">
    <div class="modal-icon" id="win-icon">ğŸ†</div>
    <h2 id="win-title">á€”á€­á€¯á€„á€ºá€á€Šá€º!</h2>
    <p id="win-msg">á€‚á€¯á€á€ºá€šá€°á€•á€«á€á€Šá€º!</p>
    <button class="btn btn-gold" onclick="ui.resetGame()" style="margin-bottom:8px">ğŸ”„ á€‘á€•á€ºá€€á€…á€¬á€¸á€•á€«</button>
    <button class="btn btn-ghost" onclick="ui.goLobby()">ğŸ  á€‘á€½á€€á€ºá€•á€«</button>
  </div>
</div>

<!-- TOAST -->
<div class="toast" id="toast"></div>

<!-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
     FIREBASE
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• -->
<script type="module">
import { initializeApp }  from "https://www.gstatic.com/firebasejs/10.7.1/firebase-app.js";
import { getDatabase, ref, set, get, onValue, update, push, remove }
  from "https://www.gstatic.com/firebasejs/10.7.1/firebase-database.js";
import { getAnalytics } from "https://www.gstatic.com/firebasejs/10.7.1/firebase-analytics.js";

const cfg = {
  apiKey:            "AIzaSyC-LM-rRPfgxIlYH9fpuZwUkSCCOPidg5g",
  authDomain:        "kyarkwat-57298.firebaseapp.com",
  databaseURL:       "https://kyarkwat-57298-default-rtdb.asia-southeast1.firebasedatabase.app",
  projectId:         "kyarkwat-57298",
  storageBucket:     "kyarkwat-57298.firebasestorage.app",
  messagingSenderId: "143473069573",
  appId:             "1:143473069573:web:127d6c9320195f10afd66c",
  measurementId:     "G-J0XHCRTFJ1"
};
const app = initializeApp(cfg);
getAnalytics(app);
const db = getDatabase(app);
window.FB = { db, ref, set, get, onValue, update, push, remove };
console.log("âœ… Firebase ready");
</script>

<!-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
     GAME ENGINE
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• -->
<script>
"use strict";

/* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
   CONSTANTS
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
const SZ   = 8;
const TURN_SECS = 60;
const DRAW_LIMIT = 40; // no-capture turns before draw

// Piece values
const EMPTY = 0;
const YEL   = 1;  // Yellow (player 1, starts bottom)
const BLU   = 2;  // Blue   (player 2, starts top)
const YELK  = 3;  // Yellow King
const BLUK  = 4;  // Blue King

/* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
   BOARD ENGINE
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
const Engine = (() => {

  // Helpers
  const isY  = p => p === YEL  || p === YELK;
  const isB  = p => p === BLU  || p === BLUK;
  const isK  = p => p === YELK || p === BLUK;
  const inBd = (r,c) => r >= 0 && r < SZ && c >= 0 && c < SZ;
  const enemy = (me, p) => (isY(me) ? isB(p) : isY(p));

  /** Clone board */
  const clone = b => b.map(r => [...r]);

  /** Fresh starting board */
  function initBoard() {
    const b = Array.from({length: SZ}, () => Array(SZ).fill(EMPTY));
    for (let r = 0; r < 3; r++)
      for (let c = 0; c < SZ; c++)
        if ((r + c) % 2 === 1) b[r][c] = BLU;
    for (let r = 5; r < SZ; r++)
      for (let c = 0; c < SZ; c++)
        if ((r + c) % 2 === 1) b[r][c] = YEL;
    return b;
  }

  /**
   * Get all CAPTURE CHAINS starting from piece at (r,c).
   * Returns array of move-chains, each chain = [{from,to,captured},...].
   * Implements Maximum Capture Rule by returning only chains with max length.
   */
  function getCaptureChains(board, r, c, visited = new Set(), depth = 0) {
    const p = board[r][c];
    if (!p) return [];

    const king = isK(p);
    const dirs = [[-1,-1],[-1,1],[1,-1],[1,1]];
    let chains = [];

    for (const [dr, dc] of dirs) {
      // King: can jump over ANY distance, so scan along the diagonal
      const maxStep = king ? SZ : 1;
      let foundEnemy = null;
      let enemyR = -1, enemyC = -1;

      for (let step = 1; step <= maxStep; step++) {
        const mr = r + dr * step;
        const mc = c + dc * step;
        if (!inBd(mr, mc)) break;

        const cell = board[mr][mc];
        if (cell === EMPTY) {
          if (foundEnemy) {
            // Landing square after enemy: valid capture
            const capKey = `${enemyR},${enemyC}`;
            if (visited.has(capKey)) {
              // Can't capture same piece twice in chain
              if (!king) break;
              continue;
            }

            // Apply this jump tentatively
            const nb = clone(board);
            nb[r][c] = EMPTY;
            nb[mr][mc] = p;
            nb[enemyR][enemyC] = EMPTY;

            const newVisited = new Set(visited);
            newVisited.add(capKey);

            const step1 = { from:[r,c], to:[mr,mc], cap:[enemyR,enemyC] };

            // Recurse for further captures
            const further = getCaptureChains(nb, mr, mc, newVisited, depth + 1);
            if (further.length > 0) {
              // Extend each further chain with this step
              for (const chain of further) {
                chains.push([step1, ...chain]);
              }
            } else {
              // No further capture: this is a terminal chain
              chains.push([step1]);
            }
            // King can continue scanning past landing squares
            if (!king) break;
          }
          // Empty square before enemy: king can keep scanning
          if (!foundEnemy && king) continue;
          if (!foundEnemy) break;
        } else if (enemy(p, cell) && !foundEnemy) {
          // Found first enemy
          foundEnemy = cell;
          enemyR = mr; enemyC = mc;
        } else {
          // Blocked
          break;
        }
      }
    }

    // Maximum Capture Rule: keep only chains that capture the most pieces
    if (chains.length > 1) {
      const maxLen = Math.max(...chains.map(c => c.length));
      chains = chains.filter(c => c.length === maxLen);
    }

    return chains;
  }

  /**
   * Get regular (non-capture) moves for piece at (r,c).
   * Returns array of {from, to, cap:null}
   */
  function getRegularMoves(board, r, c) {
    const p = board[r][c];
    if (!p) return [];
    const king = isK(p);
    const moves = [];
    // Direction: yellow goes up (dr=-1), blue goes down (dr=+1), king both
    const drs = [];
    if (isY(p) || king) drs.push(-1);
    if (isB(p) || king) drs.push(1);
    const maxStep = king ? SZ : 1;

    for (const dr of drs) {
      for (const dc of [-1, 1]) {
        for (let step = 1; step <= maxStep; step++) {
          const nr = r + dr * step;
          const nc = c + dc * step;
          if (!inBd(nr, nc)) break;
          if (board[nr][nc] !== EMPTY) break;
          moves.push({ from:[r,c], to:[nr,nc], cap:null, chain:null });
        }
      }
    }
    return moves;
  }

  /**
   * All legal moves for a color.
   * Enforces mandatory capture + maximum capture rule.
   */
  function allLegalMoves(board, color) {
    const mine = color === YEL ? [YEL, YELK] : [BLU, BLUK];
    let allChains = [];

    for (let r = 0; r < SZ; r++) {
      for (let c = 0; c < SZ; c++) {
        if (!mine.includes(board[r][c])) continue;
        const chains = getCaptureChains(board, r, c);
        allChains.push(...chains.map(ch => ({ piece:[r,c], chain:ch })));
      }
    }

    if (allChains.length > 0) {
      // Maximum Capture across ALL pieces (global maximum)
      const globalMax = Math.max(...allChains.map(a => a.chain.length));
      allChains = allChains.filter(a => a.chain.length === globalMax);
      return allChains.map(a => ({
        from: a.chain[0].from,
        to:   a.chain[a.chain.length - 1].to,
        cap:  a.chain[0].cap,
        chain: a.chain
      }));
    }

    // No captures: regular moves
    let moves = [];
    for (let r = 0; r < SZ; r++) {
      for (let c = 0; c < SZ; c++) {
        if (!mine.includes(board[r][c])) continue;
        moves.push(...getRegularMoves(board, r, c));
      }
    }
    return moves;
  }

  /**
   * Legal moves for a specific piece (respecting mandatory capture + multi-jump).
   * inMultiJump: if not null, only capture moves from that piece.
   */
  function legalForPiece(board, r, c, inMultiJump, multiJumpCaptured) {
    const p = board[r][c];
    if (!p) return [];
    const color = isY(p) ? YEL : BLU;

    if (inMultiJump) {
      // Only further captures from this piece, excluding already-captured squares
      const visited = new Set(multiJumpCaptured.map(([cr,cc]) => `${cr},${cc}`));
      const chains = getCaptureChains(board, r, c, visited);
      return chains.map(ch => ({
        from: ch[0].from,
        to:   ch[ch.length - 1].to,
        cap:  ch[0].cap,
        chain: ch
      }));
    }

    // Check if any mandatory capture exists for this color
    const allMoves = allLegalMoves(board, color);
    const hasCapture = allMoves.some(m => m.cap !== null);
    if (hasCapture) {
      // Only capture moves for THIS piece
      const chains = getCaptureChains(board, r, c);
      if (!chains.length) return []; // this piece can't capture
      const globalMaxLen = Math.max(...allMoves.map(m => m.chain ? m.chain.length : 1));
      const filtered = chains.filter(ch => ch.length === globalMaxLen);
      return filtered.map(ch => ({
        from: ch[0].from,
        to:   ch[ch.length-1].to,
        cap:  ch[0].cap,
        chain: ch
      }));
    }

    return getRegularMoves(board, r, c);
  }

  /**
   * Apply ONE step of a chain to the board.
   */
  function applyStep(board, step) {
    const nb = clone(board);
    const [fr, fc] = step.from;
    const [tr, tc] = step.to;
    const p = nb[fr][fc];
    nb[tr][tc] = p;
    nb[fr][fc] = EMPTY;
    if (step.cap) {
      const [cr, cc] = step.cap;
      nb[cr][cc] = EMPTY;
    }
    // King promotion (only after full move resolves, but mark here too)
    if (p === YEL && tr === 0)       nb[tr][tc] = YELK;
    if (p === BLU && tr === SZ - 1)  nb[tr][tc] = BLUK;
    return nb;
  }

  /**
   * Apply full chain to board.
   */
  function applyChain(board, chain) {
    let b = board;
    for (const step of chain) b = applyStep(b, step);
    return b;
  }

  /**
   * Count pieces.
   */
  function count(board) {
    let y = 0, b = 0;
    for (let r = 0; r < SZ; r++)
      for (let c = 0; c < SZ; c++) {
        if (isY(board[r][c])) y++;
        else if (isB(board[r][c])) b++;
      }
    return { y, b };
  }

  return { initBoard, allLegalMoves, legalForPiece, applyStep, applyChain, count, isY, isB, isK, clone };
})();

/* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
   AI ENGINE  (Minimax + Alpha-Beta)
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
const AI = (() => {

  function evaluate(board) {
    let score = 0;
    for (let r = 0; r < SZ; r++) {
      for (let c = 0; c < SZ; c++) {
        const p = board[r][c];
        if (!p) continue;
        const k = Engine.isK(p);
        const isBlue = Engine.isB(p);
        const val = k ? 3.5 : 1;
        const advance = k ? 0 : (isBlue ? r * 0.1 : (SZ-1-r) * 0.1);
        const center = (c >= 2 && c <= 5) ? 0.12 : 0;
        score += isBlue ? (val + advance + center) : -(val + advance + center);
      }
    }
    return score;
  }

  function minimax(board, depth, alpha, beta, maxing) {
    const { y, b } = Engine.count(board);
    if (!b) return -9999;
    if (!y) return  9999;
    const color = maxing ? BLU : YEL;
    const moves = Engine.allLegalMoves(board, color);
    if (!moves.length) return maxing ? -9999 : 9999;
    if (!depth) return evaluate(board);

    if (maxing) {
      let v = -Infinity;
      for (const mv of moves) {
        const nb = mv.chain ? Engine.applyChain(board, mv.chain) : Engine.applyStep(board, { from:mv.from, to:mv.to, cap:mv.cap });
        v = Math.max(v, minimax(nb, depth-1, alpha, beta, false));
        alpha = Math.max(alpha, v);
        if (beta <= alpha) break;
      }
      return v;
    } else {
      let v = Infinity;
      for (const mv of moves) {
        const nb = mv.chain ? Engine.applyChain(board, mv.chain) : Engine.applyStep(board, { from:mv.from, to:mv.to, cap:mv.cap });
        v = Math.min(v, minimax(nb, depth-1, alpha, beta, true));
        beta = Math.min(beta, v);
        if (beta <= alpha) break;
      }
      return v;
    }
  }

  function getBestMove(board, depth = 4) {
    const moves = Engine.allLegalMoves(board, BLU);
    if (!moves.length) return null;
    let best = null, bestScore = -Infinity;
    for (const mv of moves) {
      const nb = mv.chain ? Engine.applyChain(board, mv.chain) : Engine.applyStep(board, { from:mv.from, to:mv.to, cap:mv.cap });
      const sc = minimax(nb, depth-1, -Infinity, Infinity, false);
      if (sc > bestScore) { bestScore = sc; best = mv; }
    }
    return best;
  }

  return { getBestMove };
})();

/* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
   GAME STATE
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
let G = {
  board:    Engine.initBoard(),
  turn:     YEL,
  selR:     null,
  selC:     null,
  validMvs: [],            // legal moves for selected piece
  multiJump: null,        // {r, c, captured:[]} if in multi-jump
  noCapTurns: 0,
  over:     false,
  history:  []
};

// Session / network
let mode      = 'local'; // 'local' | 'ai' | 'online'
let myColor   = YEL;
let isMyTurn  = true;
let roomId    = null;
let p1Name    = 'á€€á€…á€¬á€¸á€á€™á€¬á€¸ á';
let p2Name    = 'á€€á€…á€¬á€¸á€á€™á€¬á€¸ á‚';
let scores    = { y: 0, b: 0 };

// Timer
let timerID   = null;
let timeLeft  = TURN_SECS;

// Board pixel size (for SVG arrows)
let cellPx    = 0;

/* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
   RENDER ENGINE
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
function calcBoardSize() {
  // Fit board in available play-area
  const playArea = document.querySelector('.play-area');
  if (!playArea) return 320;
  const h = playArea.clientHeight || window.innerHeight;
  const w = playArea.clientWidth  || window.innerWidth;
  // Rough estimate: board is main element, leave room for other UI
  const available = Math.min(w - 20, h - 220);
  return Math.max(200, Math.min(available, 460));
}

function render() {
  const boardEl = document.getElementById('board');
  boardEl.innerHTML = '';

  const size = calcBoardSize();
  document.getElementById('board').style.cssText = `width:${size}px;height:${size}px`;
  cellPx = size / SZ;

  // Flip board for blue in online mode
  const flip = (mode === 'online' && myColor === BLU);

  for (let ri = 0; ri < SZ; ri++) {
    for (let ci = 0; ci < SZ; ci++) {
      const r = flip ? (SZ-1-ri) : ri;
      const c = flip ? (SZ-1-ci) : ci;
      const dark = (r + c) % 2 === 1;

      const cell = document.createElement('div');
      cell.className = 'cell ' + (dark ? 'dk' : 'lt');
      cell.dataset.r = r;
      cell.dataset.c = c;

      // Selection highlight
      if (G.selR === r && G.selC === c) cell.classList.add('sel');

      // Valid move destination
      const vm = dark && G.validMvs.some(m => m.to[0] === r && m.to[1] === c);
      if (vm) {
        cell.classList.add('vm');
        cell.addEventListener('click', () => handleDestClick(r, c));
      } else {
        cell.addEventListener('click', () => handleCellClick(r, c));
      }

      // Piece
      const p = G.board[r][c];
      if (p !== EMPTY) {
        const pe = document.createElement('div');
        pe.className = 'piece ' + (Engine.isY(p) ? 'py' : 'pb') + (Engine.isK(p) ? ' king' : '');
        if (G.selR === r && G.selC === c) pe.classList.add('lifted');
        pe.addEventListener('click', ev => { ev.stopPropagation(); handlePieceClick(r, c); });
        cell.appendChild(pe);
      }

      boardEl.appendChild(cell);
    }
  }

  // Counts
  const { y, b } = Engine.count(G.board);
  document.getElementById('pcount1').textContent = `á€€á€»á€¬á€¸: ${y}`;
  document.getElementById('pcount2').textContent = `á€€á€»á€¬á€¸: ${b}`;
  document.getElementById('pc1').classList.toggle('active', G.turn === YEL);
  document.getElementById('pc2').classList.toggle('active', G.turn === BLU);

  // Arrows after layout paint
  requestAnimationFrame(() => {
    const fc = boardEl.querySelector('.cell');
    if (fc) cellPx = fc.getBoundingClientRect().width;
    drawArrows(flip);
  });
}

/* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
   SVG ARROWS  (V-shape + âœ“ checkmark)
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
function drawArrows(flip) {
  const svg = document.getElementById('arrow-svg');
  svg.innerHTML = '';
  if (G.selR === null || !G.validMvs.length || cellPx < 4) return;

  const board = document.getElementById('board');
  const br    = board.getBoundingClientRect();
  const sr    = svg.getBoundingClientRect();
  const ox    = br.left - sr.left;
  const oy    = br.top  - sr.top;

  const toVisual = (r, c) => ({
    x: ox + ((flip ? SZ-1-c : c) + .5) * cellPx,
    y: oy + ((flip ? SZ-1-r : r) + .5) * cellPx
  });

  const { x: sx, y: sy } = toVisual(G.selR, G.selC);

  for (const mv of G.validMvs) {
    const { x: tx, y: ty } = toVisual(mv.to[0], mv.to[1]);

    // V midpoint (apex slightly above mid)
    const mx = (sx + tx) / 2;
    const my = Math.min(sy, ty) + Math.abs(ty - sy) * 0.05;

    const mkLine = (x1, y1, x2, y2) => {
      const l = document.createElementNS('http://www.w3.org/2000/svg', 'line');
      l.setAttribute('x1', x1); l.setAttribute('y1', y1);
      l.setAttribute('x2', x2); l.setAttribute('y2', y2);
      l.setAttribute('stroke', '#22dd44');
      l.setAttribute('stroke-width', '2.5');
      l.setAttribute('stroke-linecap', 'round');
      l.setAttribute('opacity', '0.9');
      return l;
    };

    svg.appendChild(mkLine(sx, sy, mx, my));
    svg.appendChild(mkLine(mx, my, tx, ty));

    // Circle at destination
    const rad = cellPx * 0.2;
    const ci = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
    ci.setAttribute('cx', tx); ci.setAttribute('cy', ty); ci.setAttribute('r', rad);
    ci.setAttribute('fill', '#22dd4433');
    ci.setAttribute('stroke', '#22dd44');
    ci.setAttribute('stroke-width', '2');
    svg.appendChild(ci);

    // Checkmark âœ“
    const ck = rad * 0.6;
    const poly = document.createElementNS('http://www.w3.org/2000/svg', 'polyline');
    poly.setAttribute('points',
      `${tx - ck},${ty} ${tx - ck*.2},${ty + ck*.7} ${tx + ck},${ty - ck*.7}`);
    poly.setAttribute('stroke', '#22dd44');
    poly.setAttribute('stroke-width', '2');
    poly.setAttribute('fill', 'none');
    poly.setAttribute('stroke-linecap', 'round');
    poly.setAttribute('stroke-linejoin', 'round');
    svg.appendChild(poly);
  }
}

/* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
   INPUT HANDLERS
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
function canControl() {
  if (G.over) return false;
  if (mode === 'local') return true;
  if (mode === 'ai')    return G.turn === YEL;
  // online
  return isMyTurn && G.turn === myColor;
}

function handlePieceClick(r, c) {
  if (!canControl()) return;
  const p = G.board[r][c];
  if (!p) return;

  // Multi-jump: only allow the jumping piece
  if (G.multiJump) {
    if (r === G.multiJump.r && c === G.multiJump.c) selectPiece(r, c);
    else toast('âš ï¸ á€†á€€á€ºá€–á€™á€ºá€¸á€”á€­á€¯á€„á€ºá€á€±á€¬á€€á€»á€¬á€¸á€€á€­á€¯ á€›á€½á€±á€¸á€•á€«!');
    return;
  }

  // Must be my turn's color
  if (mode === 'local') {
    if (Engine.isY(p) !== (G.turn === YEL)) return;
  } else if (mode === 'ai') {
    if (!Engine.isY(p)) return;
  } else {
    if (myColor === YEL && !Engine.isY(p)) return;
    if (myColor === BLU && !Engine.isB(p)) return;
  }

  selectPiece(r, c);
}

function selectPiece(r, c) {
  const captured = G.multiJump ? G.multiJump.captured : [];
  const legal = Engine.legalForPiece(G.board, r, c, G.multiJump, captured);

  if (!legal.length) {
    // Check if mandatory capture requires another piece
    const allMvs = Engine.allLegalMoves(G.board, G.turn);
    if (allMvs.some(m => m.cap)) {
      toast('âš ï¸ á€’á€®á€€á€»á€¬á€¸á€€á€­á€¯ á€›á€½á€±á€·á€™á€›á€•á€« â€” á€–á€™á€ºá€¸á€”á€­á€¯á€„á€ºá€á€±á€¬á€€á€»á€¬á€¸á€€á€­á€¯ á€›á€½á€±á€¸á€•á€«!');
    } else {
      toast('âš ï¸ á€’á€®á€€á€»á€¬á€¸á€€á€­á€¯ á€›á€½á€±á€·áá€™á€›á€•á€«');
    }
    return;
  }

  G.selR = r; G.selC = c;
  G.validMvs = legal;
  render();
}

function handleCellClick(r, c) {
  const p = G.board[r][c];
  if (p && canControl()) { handlePieceClick(r, c); return; }
  // Deselect
  if (G.selR !== null && !G.multiJump) {
    G.selR = null; G.selC = null; G.validMvs = [];
    render();
  }
}

function handleDestClick(r, c) {
  if (G.selR === null) return;
  const mv = G.validMvs.find(m => m.to[0] === r && m.to[1] === c);
  if (mv) executeMove(mv);
}

/* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
   EXECUTE MOVE
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
function executeMove(mv) {
  const isCapture = mv.cap !== null;

  if (isCapture) {
    // Apply entire chain at once (Maximum Capture path)
    G.board = Engine.applyChain(G.board, mv.chain);
    G.noCapTurns = 0;
    logMove(mv, true);
    // Check for further captures (multi-jump should already be covered by chain,
    // but keep multi-jump state clear since chain covers it fully)
    G.multiJump = null;
  } else {
    G.board = Engine.applyStep(G.board, { from: mv.from, to: mv.to, cap: null });
    G.noCapTurns++;
    logMove(mv, false);
    G.multiJump = null;
  }

  G.selR = null; G.selC = null; G.validMvs = [];

  // Switch turn
  G.turn = G.turn === YEL ? BLU : YEL;

  // Win / draw check
  const { y, b } = Engine.count(G.board);
  if (!b) { endGame(YEL); return; }
  if (!y) { endGame(BLU); return; }
  const nextMoves = Engine.allLegalMoves(G.board, G.turn);
  if (!nextMoves.length) { endGame(G.turn === YEL ? BLU : YEL); return; }
  if (G.noCapTurns >= DRAW_LIMIT) { endGame(null); return; } // draw

  render();
  updateTurnStatus();
  resetTimer();

  // Firebase sync
  if (mode === 'online') pushFirebase();
  // AI move
  if (mode === 'ai' && G.turn === BLU) setTimeout(doAIMove, 700);
}

/* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
   AI MOVE
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
function doAIMove() {
  if (G.over || G.turn !== BLU) return;
  const mv = AI.getBestMove(G.board, 4);
  if (!mv) return;
  G.selR = mv.from[0]; G.selC = mv.from[1];
  render();
  setTimeout(() => executeMove(mv), 350);
}

/* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
   TIMER
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
function resetTimer() {
  clearInterval(timerID);
  timeLeft = TURN_SECS;
  updateTimerEl();
  timerID = setInterval(() => {
    timeLeft--;
    updateTimerEl();
    if (timeLeft <= 0) {
      clearInterval(timerID);
      toast('â° á€¡á€á€»á€­á€”á€ºá€€á€¯á€”á€ºá€á€Šá€º! á€œá€¾á€Šá€·á€ºá€•á€¼á€±á€¬á€„á€ºá€¸á€á€Šá€º');
      forfeitTurn();
    }
  }, 1000);
}

function forfeitTurn() {
  G.selR = null; G.selC = null; G.validMvs = []; G.multiJump = null;
  G.turn = G.turn === YEL ? BLU : YEL;
  render(); updateTurnStatus(); resetTimer();
  if (mode === 'online') pushFirebase();
  if (mode === 'ai' && G.turn === BLU) setTimeout(doAIMove, 700);
}

function updateTimerEl() {
  const el = document.getElementById('timer');
  el.textContent = timeLeft;
  el.classList.toggle('urgent', timeLeft <= 10);
}

/* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
   STATUS / LOG
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
function setStatus(msg) { document.getElementById('status').textContent = msg; }

function updateTurnStatus() {
  if (G.over) return;
  if (mode === 'local') {
    setStatus(`ğŸ® ${G.turn === YEL ? p1Name : p2Name} áá€¡á€œá€¾á€Šá€·á€º â€” á€€á€»á€¬á€¸á€€á€­á€¯á€”á€¾á€­á€•á€ºá€•á€«`);
  } else if (mode === 'ai') {
    setStatus(G.turn === YEL ? 'ğŸŸ¡ á€á€„á€·á€ºá€¡á€œá€¾á€Šá€·á€º â€” á€€á€»á€¬á€¸á€€á€­á€¯á€”á€¾á€­á€•á€ºá€•á€«' : 'ğŸ”µ AI á€…á€‰á€ºá€¸á€…á€¬á€¸á€”á€±á€á€Šá€º...');
  } else {
    isMyTurn = G.turn === myColor;
    setStatus(isMyTurn ? 'ğŸ¯ á€á€„á€·á€ºá€¡á€œá€¾á€Šá€·á€º â€” á€€á€»á€¬á€¸á€€á€­á€¯á€”á€¾á€­á€•á€ºá€•á€«' : 'â³ á€†á€”á€·á€ºá€€á€»á€„á€ºá€˜á€€á€ºá€€á€…á€¬á€¸á€”á€±á€á€Šá€º...');
  }
}

const COL = 'ABCDEFGH';
function logMove(mv, capture) {
  const f = COL[mv.from[1]] + (SZ - mv.from[0]);
  const t = COL[mv.to[1]]   + (SZ - mv.to[0]);
  const captureCount = mv.chain ? mv.chain.length : (capture ? 1 : 0);
  G.history.push({
    txt: `${f}â†’${t}${capture ? 'Ã—' + captureCount : ''}`,
    col: G.turn === YEL ? 'y-mv' : 'b-mv'
  });
  const el = document.getElementById('move-log');
  el.innerHTML = '';
  G.history.slice(-30).forEach(h => {
    const s = document.createElement('span');
    s.className = h.col; s.textContent = h.txt; el.appendChild(s);
  });
  el.scrollTop = el.scrollHeight;
}

/* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
   END GAME
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
function endGame(winner) {
  G.over = true;
  clearInterval(timerID);

  let icon, title, msg;
  if (winner === null) {
    icon = 'ğŸ¤'; title = 'á€á€›á€±!'; msg = `á€–á€™á€ºá€¸á€™á€¾á€¯ ${DRAW_LIMIT} á€€á€¼á€­á€™á€ºá€á€½á€„á€º á€™á€•á€¼á€±á€¬á€„á€ºá€¸á€œá€²á€á€–á€¼á€„á€·á€º á€á€›á€±á€€á€»á€á€Šá€º`;
  } else {
    const yw = winner === YEL;
    if (yw) scores.y++; else scores.b++;
    document.getElementById('score1').textContent = scores.y;
    document.getElementById('score2').textContent = scores.b;
    const wName = yw ? p1Name : p2Name;
    icon  = yw ? 'ğŸŸ¡' : 'ğŸ”µ';
    title = `${wName} á€”á€­á€¯á€„á€ºá€á€Šá€º!`;
    msg   = mode === 'ai'
      ? (yw ? 'ğŸ‰ AI á€€á€­á€¯á€”á€­á€¯á€„á€ºá€á€Šá€º! á€‚á€¯á€á€ºá€šá€°á€•á€«á€á€Šá€º!' : 'ğŸ’ª AI á€€á€”á€­á€¯á€„á€ºá€á€Šá€º! á€‘á€•á€ºá€€á€¼á€­á€¯á€¸á€…á€¬á€¸á€•á€«!')
      : 'ğŸ† á€€á€±á€¬á€„á€ºá€¸á€á€±á€¬á€€á€…á€¬á€¸á€™á€¾á€¯!';
  }

  document.getElementById('win-icon').textContent  = icon;
  document.getElementById('win-title').textContent = title;
  document.getElementById('win-msg').textContent   = msg;
  document.getElementById('win-overlay').classList.add('show');
  render();
}

/* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
   FIREBASE MULTIPLAYER
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
function genCode() { return Math.random().toString(36).substr(2,6).toUpperCase(); }
let fbUnsub = null;

function pushFirebase() {
  if (!window.FB || !roomId) return;
  const { db, ref, set } = window.FB;
  set(ref(db, `rooms/${roomId}/gs`), {
    board: G.board, turn: G.turn,
    noCapTurns: G.noCapTurns, t: Date.now()
  });
  isMyTurn = false;
}

function listenFirebase() {
  if (!window.FB || !roomId) return;
  const { db, ref, onValue } = window.FB;
  fbUnsub = onValue(ref(db, `rooms/${roomId}/gs`), snap => {
    const d = snap.val();
    if (!d) return;
    if (d.turn !== myColor) return; // not my turn yet
    G.board = d.board; G.turn = d.turn;
    G.noCapTurns = d.noCapTurns || 0;
    G.selR = null; G.selC = null; G.validMvs = []; G.multiJump = null;
    isMyTurn = true;
    render(); updateTurnStatus(); resetTimer();
    const { y, b } = Engine.count(G.board);
    if (!b) endGame(YEL); else if (!y) endGame(BLU);
  });
}

function listenChat() {
  if (!window.FB || !roomId) return;
  const { db, ref, onValue } = window.FB;
  onValue(ref(db, `rooms/${roomId}/chat`), snap => {
    const data = snap.val();
    if (!data) return;
    const msgs = Object.values(data).sort((a,b) => a.t - b.t);
    const el = document.getElementById('chat-msgs');
    el.innerHTML = '';
    msgs.forEach(m => appendChatDOM(m.sender, m.text, m.sender === (myColor === YEL ? p1Name : p2Name)));
  });
}

/* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
   CHAT
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
function appendChatDOM(sender, text, mine) {
  const el = document.getElementById('chat-msgs');
  if (sender === 'system') {
    const d = document.createElement('div');
    d.className = 'chat-system'; d.textContent = text;
    el.appendChild(d);
  } else {
    const wrap = document.createElement('div');
    wrap.className = 'chat-msg ' + (mine ? 'mine' : 'theirs');
    wrap.innerHTML = `<div class="chat-sender">${sender}</div><div class="chat-bubble">${text}</div>`;
    el.appendChild(wrap);
  }
  el.scrollTop = el.scrollHeight;
}

function localChat(sender, text, mine) {
  appendChatDOM(sender, text, mine);
}

/* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
   UI CONTROLLER
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
const ui = {

  createRoom() {
    const name = document.getElementById('inp-name').value.trim() || 'á€€á€…á€¬á€¸á€á€™á€¬á€¸ á';
    p1Name = name; roomId = genCode(); myColor = YEL;
    const fb = window.FB;
    if (!fb) { toast('Firebase á€™á€á€»á€­á€á€ºá€†á€€á€ºá€›á€á€±á€¸á€•á€«'); return; }
    const { db, ref, set, onValue } = fb;
    set(ref(db, `rooms/${roomId}`), { p1: name, p2: null, status: 'wait' });
    document.getElementById('room-code-disp').textContent = roomId;
    document.getElementById('wait-card').style.display = 'block';
    // Wait for player 2
    onValue(ref(db, `rooms/${roomId}/p2`), snap => {
      const v = snap.val();
      if (v) { p2Name = v; this._startOnline(); }
    });
    toast(`ğŸ  Room ${roomId} á€–á€”á€ºá€á€®á€¸á€•á€¼á€®á€¸`);
  },

  joinRoom() {
    const code = document.getElementById('inp-code').value.trim().toUpperCase();
    const name = document.getElementById('inp-name').value.trim() || 'á€€á€…á€¬á€¸á€á€™á€¬á€¸ á‚';
    if (code.length < 4) { toast('âš ï¸ Code á€‘á€Šá€·á€ºá€•á€«'); return; }
    p2Name = name; roomId = code; myColor = BLU;
    const fb = window.FB;
    if (!fb) { toast('Firebase á€™á€á€»á€­á€á€ºá€†á€€á€ºá€›á€á€±á€¸á€•á€«'); return; }
    const { db, ref, get, update } = fb;
    get(ref(db, `rooms/${code}`)).then(snap => {
      const d = snap.val();
      if (!d)   { toast('âŒ Room á€™á€á€½á€±á€·á€•á€«'); return; }
      if (d.p2) { toast('âŒ Room á€•á€¼á€Šá€·á€ºá€”á€±á€á€Šá€º'); return; }
      p1Name = d.p1;
      update(ref(db, `rooms/${code}`), { p2: name, status: 'play' });
      this._startOnline();
      toast(`âœ… Room ${code} á€á€„á€ºá€•á€¼á€®á€¸`);
    });
  },

  _startOnline() {
    document.getElementById('wait-card').style.display = 'none';
    mode = 'online'; isMyTurn = myColor === YEL;
    this._freshGame(); this._showGame();
    listenFirebase();
    listenChat();
    localChat('system', `Room: ${roomId} | ${p1Name} ğŸŸ¡ VS ğŸ”µ ${p2Name}`, false);
  },

  cancelRoom() {
    if (roomId && window.FB)
      window.FB.remove(window.FB.ref(window.FB.db, `rooms/${roomId}`));
    roomId = null;
    document.getElementById('wait-card').style.display = 'none';
  },

  startAI() {
    p1Name = document.getElementById('inp-name').value.trim() || 'á€€á€…á€¬á€¸á€á€™á€¬á€¸ á';
    p2Name = 'ğŸ¤– AI'; mode = 'ai'; myColor = YEL; isMyTurn = true; roomId = null;
    this._freshGame(); this._showGame();
    localChat('system', `${p1Name} VS AI â€” AI á€€ á€˜á€šá€ºá€˜á€€á€º (ğŸ”µ)`, false);
  },

  startLocal() {
    p1Name = document.getElementById('inp-name').value.trim() || 'á€€á€…á€¬á€¸á€á€™á€¬á€¸ á';
    p2Name = 'á€€á€…á€¬á€¸á€á€™á€¬á€¸ á‚'; mode = 'local'; myColor = YEL; isMyTurn = true; roomId = null;
    this._freshGame(); this._showGame();
    localChat('system', `${p1Name} ğŸŸ¡ VS ğŸ”µ ${p2Name}`, false);
  },

  _freshGame() {
    clearInterval(timerID);
    G = {
      board: Engine.initBoard(), turn: YEL,
      selR: null, selC: null, validMvs: [],
      multiJump: null, noCapTurns: 0, over: false, history: []
    };
  },

  _showGame() {
    document.getElementById('lobby').classList.remove('active');
    document.getElementById('game').classList.add('active');
    document.getElementById('pname1').textContent = p1Name;
    document.getElementById('pname2').textContent = p2Name;
    document.getElementById('sname1').textContent = p1Name;
    document.getElementById('sname2').textContent = p2Name;
    updateTurnStatus(); render(); resetTimer();
  },

  resetGame() {
    document.getElementById('win-overlay').classList.remove('show');
    this._freshGame();
    isMyTurn = myColor === YEL || mode === 'local';
    updateTurnStatus(); render(); resetTimer();
    if (mode === 'ai' && G.turn === BLU) setTimeout(doAIMove, 700);
    document.getElementById('move-log').innerHTML = '';
    document.getElementById('chat-msgs').innerHTML = '';
    localChat('system', 'â€” á€€á€…á€¬á€¸á€™á€¾á€¯á€á€…á€º á€…á€á€„á€ºá€á€Šá€º â€”', false);
  },

  goLobby() {
    clearInterval(timerID);
    if (roomId && window.FB)
      window.FB.remove(window.FB.ref(window.FB.db, `rooms/${roomId}`));
    roomId = null; fbUnsub = null;
    document.getElementById('win-overlay').classList.remove('show');
    document.getElementById('game').classList.remove('active');
    document.getElementById('lobby').classList.add('active');
    document.getElementById('wait-card').style.display = 'none';
    document.getElementById('move-log').innerHTML = '';
    document.getElementById('chat-msgs').innerHTML = '';
  },

  offerDraw() {
    const msg = 'á€á€›á€±á€•á€±á€¸á€”á€­á€¯á€„á€ºá€™á€œá€¬á€¸? ğŸ¤';
    if (mode === 'online') {
      ui.sendChatText(msg);
    } else {
      const ok = confirm('á€á€›á€± (Draw) á€€á€¼á€±á€Šá€¬á€™á€Šá€ºá€œá€¬á€¸?');
      if (ok) endGame(null);
    }
  },

  sendChat() {
    const inp = document.getElementById('chat-inp');
    const text = inp.value.trim();
    if (!text) return;
    inp.value = '';
    const sender = myColor === YEL ? p1Name : p2Name;
    if (mode === 'online' && window.FB && roomId) {
      const { db, ref, push } = window.FB;
      push(ref(db, `rooms/${roomId}/chat`), { sender, text, t: Date.now() });
    } else {
      // Local chat (both players same screen)
      localChat(sender, text, G.turn === YEL);
    }
  },

  sendChatText(text) {
    const sender = myColor === YEL ? p1Name : p2Name;
    if (mode === 'online' && window.FB && roomId) {
      const { db, ref, push } = window.FB;
      push(ref(db, `rooms/${roomId}/chat`), { sender, text, t: Date.now() });
    } else {
      localChat(sender, text, true);
    }
  }
};

// Expose to HTML onclick
window.ui = ui;

/* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
   INIT
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
document.addEventListener('DOMContentLoaded', () => {
  document.getElementById('inp-code').addEventListener('input', e => {
    e.target.value = e.target.value.toUpperCase().replace(/[^A-Z0-9]/g,'');
  });
  document.addEventListener('contextmenu', e => {
    if (e.target.closest('#board')) e.preventDefault();
  });
  window.addEventListener('resize', () => { if (!G.over) render(); });
});

/* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
   TOAST
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
let toastTid = null;
function toast(msg) {
  const el = document.getElementById('toast');
  el.textContent = msg; el.classList.add('show');
  clearTimeout(toastTid);
  toastTid = setTimeout(() => el.classList.remove('show'), 3200);
}
</script>
</body>
</html>
